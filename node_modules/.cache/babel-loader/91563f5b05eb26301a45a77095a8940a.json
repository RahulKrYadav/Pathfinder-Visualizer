{"ast":null,"code":"import PriorityQueue from \"js-priority-queue\";\n\nconst jumpPointSearch = (grid, startNode, endNode) => {\n  let visitedNodes = [];\n  let shortestPath = [];\n  let pq = new PriorityQueue({\n    comparator: function (a, b) {\n      return a.node.f - b.node.f;\n    }\n  });\n  grid.forEach(row => {\n    row.forEach(node => {\n      //g : distance\n      node.g = Infinity; //f = g + h\n\n      node.f = Infinity;\n      node.prevNode = null;\n    });\n  });\n  grid[startNode.row][startNode.column].g = 0;\n  grid[startNode.row][startNode.column].f = H(startNode.row, startNode.column, endNode); //grid[startNode.row][startNode.column].isWall = false;\n  //grid[endNode.row][endNode.column].isWall = false;\n\n  const n = [[1, 0], [0, 1], [-1, 0], [0, -1], [-1, 1], [1, 1], [-1, -1], [1, -1]];\n  n.forEach(d => {\n    pq.queue({\n      node: grid[startNode.row][startNode.column],\n      dir: d\n    }); //grid[startNode.row][startNode.column].prevNode[d[0]][d[1]] = null;\n  });\n\n  while (pq.length) {\n    const obj = pq.dequeue();\n\n    if (!obj.node.isVisited) {\n      obj.node.isVisited = true;\n      visitedNodes.push(obj.node);\n    }\n    /*console.log(\n      obj.node.row + \",\" + obj.node.col + \"-dir:\" + obj.dir + \"-f:\" + obj.node.f\n    );*/\n\n\n    const response = scan(obj.node, obj.dir, grid, endNode, pq);\n\n    if (response === \"found\") {\n      break;\n    }\n  }\n\n  shortestPath = getShortestPath(grid[endNode.row][endNode.column]);\n  return {\n    visitedNodes,\n    shortestPath\n  };\n}; //x = c // y = r\n//hor = y // ver = x\n\n\nconst scan = (node, dir, grid, endNode, pq) => {\n  const x = dir[0];\n  const y = dir[1];\n\n  if (x !== 0 && y !== 0) {\n    let r0 = node.row;\n    let c0 = node.col;\n\n    while (true) {\n      //console.log(\"diag\");\n      //console.log(r0, c0);\n      let c1 = c0 + y;\n      let r1 = r0 + x;\n      if (!inGrid(r1, c1, grid)) return false;\n      let g = grid[r1][c1];\n      let ng = grid[r0][c0].g + 1;\n      let nf = ng + H(r1, c1, endNode);\n      if (g.f <= nf) return false;\n      g.g = ng;\n      g.f = nf;\n\n      if (g.row === endNode.row && g.col === endNode.column) {\n        grid[r1][c1].prevNode = grid[r0][c0];\n        return \"found\";\n      }\n\n      if (g.isWall) return false;\n      grid[r1][c1].prevNode = grid[r0][c0];\n      let c2 = c1 + y;\n      let r2 = r1 + x;\n      let jump = false;\n\n      if (inGrid(r1, c0, grid) && grid[r1][c0].isWall && inGrid(r2, c0, grid) && (!grid[r2][c0].isWall || r2 === endNode.row && c0 === endNode.column)) {\n        pq.queue({\n          node: grid[r1][c1],\n          dir: [x, -y]\n        });\n        jump = true;\n      }\n\n      if (inGrid(r0, c1, grid) && grid[r0][c1].isWall && inGrid(r0, c2, grid) && (!grid[r0][c2].isWall || r0 === endNode.row && c2 === endNode.column)) {\n        pq.queue({\n          node: grid[r1][c1],\n          dir: [-x, y]\n        });\n        jump = true;\n      }\n\n      let hor = scan(grid[r1][c1], [0, y], grid, endNode, pq);\n      let ver = scan(grid[r1][c1], [x, 0], grid, endNode, pq);\n      if (hor === \"found\" || ver === \"found\") return \"found\";\n\n      if (hor || ver) {\n        jump = true;\n      }\n\n      if (jump) {\n        pq.queue({\n          node: grid[r1][c1],\n          dir: [x, y]\n        });\n        return true;\n      }\n\n      c0 = c1;\n      r0 = r1;\n    }\n  } else if (x === 0) {\n    let r0 = node.row;\n    let c0 = node.col;\n\n    while (true) {\n      //console.log(\"row\");\n      //console.log(r0, c0);\n      let c1 = c0 + y;\n      if (!inGrid(r0, c1, grid)) return false;\n      let g = grid[r0][c1];\n      let ng = grid[r0][c0].g + 1;\n      let nf = ng + H(r0, c1, endNode);\n      if (g.f <= nf) return false;\n      g.g = ng;\n      g.f = nf;\n\n      if (g.row === endNode.row && g.col === endNode.column) {\n        grid[r0][c1].prevNode = grid[r0][c0];\n        return \"found\";\n      }\n\n      if (g.isWall) return false;\n      grid[r0][c1].prevNode = grid[r0][c0];\n      let c2 = c1 + y;\n      let jump = false;\n\n      if (inGrid(r0 - 1, c1, grid) && grid[r0 - 1][c1].isWall && inGrid(r0 - 1, c2, grid) && (!grid[r0 - 1][c2].isWall || r0 - 1 === endNode.row && c2 === endNode.column)) {\n        pq.queue({\n          node: grid[r0][c1],\n          dir: [-1, y]\n        });\n        jump = true;\n      }\n\n      if (inGrid(r0 + 1, c1, grid) && grid[r0 + 1][c1].isWall && inGrid(r0 + 1, c2, grid) && (!grid[r0 + 1][c2].isWall || r0 + 1 === endNode.row && c2 === endNode.column)) {\n        pq.queue({\n          node: grid[r0][c1],\n          dir: [1, y]\n        });\n        jump = true;\n      }\n\n      if (jump) {\n        pq.queue({\n          node: grid[r0][c1],\n          dir: [0, y]\n        });\n        return true;\n      }\n\n      c0 = c1;\n    }\n  } else if (y === 0) {\n    let r0 = node.row;\n    let c0 = node.col;\n\n    while (true) {\n      //console.log(\"col\");\n      //console.log(r0, c0);\n      let r1 = r0 + x;\n      if (!inGrid(r1, c0, grid)) return false;\n      let g = grid[r1][c0];\n      let ng = grid[r0][c0].g + 1;\n      let nf = ng + H(r1, c0, endNode);\n      if (g.f <= nf) return false;\n      g.g = ng;\n      g.f = nf;\n\n      if (g.row === endNode.row && g.col === endNode.column) {\n        grid[r1][c0].prevNode = grid[r0][c0];\n        return \"found\";\n      }\n\n      if (g.isWall) return false;\n      grid[r1][c0].prevNode = grid[r0][c0];\n      let r2 = r1 + x;\n      let jump = false;\n\n      if (inGrid(r1, c0 - 1, grid) && grid[r1][c0 - 1].isWall && inGrid(r2, c0 - 1, grid) && (!grid[r2][c0 - 1].isWall || r2 === endNode.row && c0 - 1 === endNode.column)) {\n        pq.queue({\n          node: grid[r1][c0],\n          dir: [x, -1]\n        });\n        jump = true;\n      }\n\n      if (inGrid(r1, c0 + 1, grid) && grid[r1][c0 + 1].isWall && inGrid(r2, c0 + 1, grid) && (!grid[r2][c0 + 1].isWall || r2 === endNode.row && c0 + 1 === endNode.column)) {\n        pq.queue({\n          node: grid[r1][c0],\n          dir: [x, 1]\n        });\n        jump = true;\n      }\n\n      if (jump) {\n        pq.queue({\n          node: grid[r1][c0],\n          dir: [x, y]\n        });\n        return true;\n      }\n\n      r0 = r1;\n    }\n  }\n};\n\nconst inGrid = (row, col, grid) => {\n  return grid[row] && grid[row][col];\n};\n\nconst H = (row, col, endNode) => {\n  const dx = Math.abs(row - endNode.row);\n  const dy = Math.abs(col - endNode.column);\n  const d = 1;\n  let ans = d * Math.sqrt(dx * dx + dy * dy);\n  /*if (heuristic === \"manhatten\") {\n      ans = d * (dx + dy);\n    }\n    if (heuristic === \"euclidean\") {\n      ans = d * Math.sqrt(dx * dx + dy * dy);\n    }\n    if (heuristic === \"octile\" || heuristic === \"chebyshev\") {\n      let d2 = diagDist;\n      ans = d * Math.max(dx, dy) + (d2 - d) * Math.min(dx, dy);\n    }*/\n\n  return ans;\n};\n\n_c = H;\n\nconst getShortestPath = node => {\n  let shortestPath = [];\n\n  while (node !== null) {\n    shortestPath.unshift(node);\n    node = node.prevNode;\n    if (node) node.isShortestPath = true;\n  }\n\n  return shortestPath;\n};\n\nexport default jumpPointSearch;\n\nvar _c;\n\n$RefreshReg$(_c, \"H\");","map":{"version":3,"names":["PriorityQueue","jumpPointSearch","grid","startNode","endNode","visitedNodes","shortestPath","pq","comparator","a","b","node","f","forEach","row","g","Infinity","prevNode","column","H","n","d","queue","dir","length","obj","dequeue","isVisited","push","response","scan","getShortestPath","x","y","r0","c0","col","c1","r1","inGrid","ng","nf","isWall","c2","r2","jump","hor","ver","dx","Math","abs","dy","ans","sqrt","unshift","isShortestPath"],"sources":["/Users/amitkumar/Documents/RKY/PROJECTS/Project@PathfinderVisualizer/src/algorithms/jumpPointSearch.js"],"sourcesContent":["import PriorityQueue from \"js-priority-queue\";\n\nconst jumpPointSearch = (grid, startNode, endNode) => {\n  let visitedNodes = [];\n  let shortestPath = [];\n  let pq = new PriorityQueue({\n    comparator: function(a, b) {\n      return a.node.f - b.node.f;\n    }\n  });\n  grid.forEach(row => {\n    row.forEach(node => {\n      //g : distance\n      node.g = Infinity;\n      //f = g + h\n      node.f = Infinity;\n      node.prevNode = null;\n    });\n  });\n  grid[startNode.row][startNode.column].g = 0;\n  grid[startNode.row][startNode.column].f = H(\n    startNode.row,\n    startNode.column,\n    endNode\n  );\n  //grid[startNode.row][startNode.column].isWall = false;\n  //grid[endNode.row][endNode.column].isWall = false;\n  const n = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n    [-1, 1],\n    [1, 1],\n    [-1, -1],\n    [1, -1]\n  ];\n\n  n.forEach(d => {\n    pq.queue({ node: grid[startNode.row][startNode.column], dir: d });\n    //grid[startNode.row][startNode.column].prevNode[d[0]][d[1]] = null;\n  });\n  while (pq.length) {\n    const obj = pq.dequeue();\n    if (!obj.node.isVisited) {\n      obj.node.isVisited = true;\n      visitedNodes.push(obj.node);\n    }\n    /*console.log(\n      obj.node.row + \",\" + obj.node.col + \"-dir:\" + obj.dir + \"-f:\" + obj.node.f\n    );*/\n    const response = scan(obj.node, obj.dir, grid, endNode, pq);\n    if (response === \"found\") {\n      break;\n    }\n  }\n  shortestPath = getShortestPath(grid[endNode.row][endNode.column]);\n  return { visitedNodes, shortestPath };\n};\n//x = c // y = r\n//hor = y // ver = x\nconst scan = (node, dir, grid, endNode, pq) => {\n  const x = dir[0];\n  const y = dir[1];\n  if (x !== 0 && y !== 0) {\n    let r0 = node.row;\n    let c0 = node.col;\n    while (true) {\n      //console.log(\"diag\");\n      //console.log(r0, c0);\n      let c1 = c0 + y;\n      let r1 = r0 + x;\n      if (!inGrid(r1, c1, grid)) return false;\n      let g = grid[r1][c1];\n      let ng = grid[r0][c0].g + 1;\n      let nf = ng + H(r1, c1, endNode);\n      if (g.f <= nf) return false;\n      g.g = ng;\n      g.f = nf;\n      if (g.row === endNode.row && g.col === endNode.column) {\n        grid[r1][c1].prevNode = grid[r0][c0];\n        return \"found\";\n      }\n      if (g.isWall) return false;\n      grid[r1][c1].prevNode = grid[r0][c0];\n      let c2 = c1 + y;\n      let r2 = r1 + x;\n      let jump = false;\n      if (\n        inGrid(r1, c0, grid) &&\n        grid[r1][c0].isWall &&\n        inGrid(r2, c0, grid) &&\n        (!grid[r2][c0].isWall || (r2 === endNode.row && c0 === endNode.column))\n      ) {\n        pq.queue({ node: grid[r1][c1], dir: [x, -y] });\n        jump = true;\n      }\n      if (\n        inGrid(r0, c1, grid) &&\n        grid[r0][c1].isWall &&\n        inGrid(r0, c2, grid) &&\n        (!grid[r0][c2].isWall || (r0 === endNode.row && c2 === endNode.column))\n      ) {\n        pq.queue({ node: grid[r1][c1], dir: [-x, y] });\n        jump = true;\n      }\n      let hor = scan(grid[r1][c1], [0, y], grid, endNode, pq);\n      let ver = scan(grid[r1][c1], [x, 0], grid, endNode, pq);\n      if (hor === \"found\" || ver === \"found\") return \"found\";\n      if (hor || ver) {\n        jump = true;\n      }\n      if (jump) {\n        pq.queue({ node: grid[r1][c1], dir: [x, y] });\n        return true;\n      }\n      c0 = c1;\n      r0 = r1;\n    }\n  } else if (x === 0) {\n    let r0 = node.row;\n    let c0 = node.col;\n    while (true) {\n      //console.log(\"row\");\n      //console.log(r0, c0);\n      let c1 = c0 + y;\n      if (!inGrid(r0, c1, grid)) return false;\n      let g = grid[r0][c1];\n      let ng = grid[r0][c0].g + 1;\n      let nf = ng + H(r0, c1, endNode);\n      if (g.f <= nf) return false;\n      g.g = ng;\n      g.f = nf;\n      if (g.row === endNode.row && g.col === endNode.column) {\n        grid[r0][c1].prevNode = grid[r0][c0];\n        return \"found\";\n      }\n      if (g.isWall) return false;\n      grid[r0][c1].prevNode = grid[r0][c0];\n      let c2 = c1 + y;\n      let jump = false;\n      if (\n        inGrid(r0 - 1, c1, grid) &&\n        grid[r0 - 1][c1].isWall &&\n        inGrid(r0 - 1, c2, grid) &&\n        (!grid[r0 - 1][c2].isWall ||\n          (r0 - 1 === endNode.row && c2 === endNode.column))\n      ) {\n        pq.queue({ node: grid[r0][c1], dir: [-1, y] });\n        jump = true;\n      }\n      if (\n        inGrid(r0 + 1, c1, grid) &&\n        grid[r0 + 1][c1].isWall &&\n        inGrid(r0 + 1, c2, grid) &&\n        (!grid[r0 + 1][c2].isWall ||\n          (r0 + 1 === endNode.row && c2 === endNode.column))\n      ) {\n        pq.queue({ node: grid[r0][c1], dir: [1, y] });\n        jump = true;\n      }\n      if (jump) {\n        pq.queue({ node: grid[r0][c1], dir: [0, y] });\n        return true;\n      }\n      c0 = c1;\n    }\n  } else if (y === 0) {\n    let r0 = node.row;\n    let c0 = node.col;\n    while (true) {\n      //console.log(\"col\");\n      //console.log(r0, c0);\n      let r1 = r0 + x;\n      if (!inGrid(r1, c0, grid)) return false;\n      let g = grid[r1][c0];\n      let ng = grid[r0][c0].g + 1;\n      let nf = ng + H(r1, c0, endNode);\n      if (g.f <= nf) return false;\n      g.g = ng;\n      g.f = nf;\n      if (g.row === endNode.row && g.col === endNode.column) {\n        grid[r1][c0].prevNode = grid[r0][c0];\n        return \"found\";\n      }\n      if (g.isWall) return false;\n      grid[r1][c0].prevNode = grid[r0][c0];\n      let r2 = r1 + x;\n      let jump = false;\n      if (\n        inGrid(r1, c0 - 1, grid) &&\n        grid[r1][c0 - 1].isWall &&\n        inGrid(r2, c0 - 1, grid) &&\n        (!grid[r2][c0 - 1].isWall ||\n          (r2 === endNode.row && c0 - 1 === endNode.column))\n      ) {\n        pq.queue({ node: grid[r1][c0], dir: [x, -1] });\n        jump = true;\n      }\n      if (\n        inGrid(r1, c0 + 1, grid) &&\n        grid[r1][c0 + 1].isWall &&\n        inGrid(r2, c0 + 1, grid) &&\n        (!grid[r2][c0 + 1].isWall ||\n          (r2 === endNode.row && c0 + 1 === endNode.column))\n      ) {\n        pq.queue({ node: grid[r1][c0], dir: [x, 1] });\n        jump = true;\n      }\n      if (jump) {\n        pq.queue({ node: grid[r1][c0], dir: [x, y] });\n        return true;\n      }\n      r0 = r1;\n    }\n  }\n};\n\nconst inGrid = (row, col, grid) => {\n  return grid[row] && grid[row][col];\n};\n\nconst H = (row, col, endNode) => {\n  const dx = Math.abs(row - endNode.row);\n  const dy = Math.abs(col - endNode.column);\n  const d = 1;\n  let ans = d * Math.sqrt(dx * dx + dy * dy);\n  /*if (heuristic === \"manhatten\") {\n      ans = d * (dx + dy);\n    }\n    if (heuristic === \"euclidean\") {\n      ans = d * Math.sqrt(dx * dx + dy * dy);\n    }\n    if (heuristic === \"octile\" || heuristic === \"chebyshev\") {\n      let d2 = diagDist;\n      ans = d * Math.max(dx, dy) + (d2 - d) * Math.min(dx, dy);\n    }*/\n  return ans;\n};\n\nconst getShortestPath = node => {\n  let shortestPath = [];\n  while (node !== null) {\n    shortestPath.unshift(node);\n    node = node.prevNode;\n    if (node) node.isShortestPath = true;\n  }\n  return shortestPath;\n};\n\nexport default jumpPointSearch;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}