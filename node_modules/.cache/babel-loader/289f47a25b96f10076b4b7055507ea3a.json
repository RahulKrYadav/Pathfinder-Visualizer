{"ast":null,"code":"import PriorityQueue from \"js-priority-queue\";\n\nconst astar = (grid, startNode, endNode, heuristic, allowDiag) => {\n  let visitedNodes = [];\n  let shortestPath = [];\n  let diagDist = 1.414;\n  if (heuristic === \"chebyshev\") diagDist = 1;\n  let pq = new PriorityQueue({\n    comparator: function (a, b) {\n      //Tie-breaker\n      if (a.f === b.f) return a.h - b.h;\n      return a.f - b.f;\n    }\n  });\n  grid.forEach(row => {\n    row.forEach(node => {\n      //g : distance\n      node.g = Infinity; //h : heuristic\n\n      node.h = Infinity; //f = g + h\n\n      node.f = Infinity;\n      node.prevNode = null;\n    });\n  });\n  grid[startNode.row][startNode.column].g = 0;\n  grid[startNode.row][startNode.column].h = 0;\n  grid[startNode.row][startNode.column].f = 0;\n  pq.queue(grid[startNode.row][startNode.column]);\n\n  while (pq.length) {\n    const node = pq.dequeue();\n    const {\n      row,\n      col\n    } = node;\n    grid[row][col].isVisited = true;\n    visitedNodes.push(node);\n\n    if (node.row === endNode.row && node.col === endNode.column) {\n      shortestPath = getShortestPath(node);\n      break;\n    }\n\n    const n = [[1, 0], [0, 1], [-1, 0], [0, -1]]; //with diag\n\n    if (allowDiag) n.push([-1, 1], [1, 1], [-1, -1], [1, -1]);\n\n    for (let j = 0; j < n.length; j++) {\n      const i = n[j];\n      const r = row + i[0];\n      const c = col + i[1];\n\n      if (grid[r] && grid[r][c] && !grid[r][c].isVisited && (!grid[r][c].isWall || r === endNode.row && c === endNode.column)) {\n        if (r === endNode.row && c === endNode.column) {\n          grid[r][c].isVisited = true;\n          grid[r][c].prevNode = grid[row][col];\n          shortestPath = getShortestPath(grid[r][c]);\n          return {\n            visitedNodes,\n            shortestPath\n          };\n        }\n\n        const dist = Math.abs(i[0]) === 1 && Math.abs(i[1]) === 1 ? diagDist : 1;\n        let gNew = grid[row][col].g + dist;\n        let hNew = calculateHeuristic(r, c, endNode, heuristic, diagDist);\n        let fNew = gNew + hNew;\n\n        if (grid[r][c].f > fNew) {\n          grid[r][c].g = gNew;\n          grid[r][c].h = hNew;\n          grid[r][c].f = fNew;\n          grid[r][c].prevNode = node;\n          pq.queue(grid[r][c]);\n        }\n      }\n    }\n  }\n\n  return {\n    visitedNodes,\n    shortestPath\n  };\n};\n\nconst calculateHeuristic = (row, col, endNode, heuristic, diagDist) => {\n  const dx = Math.abs(row - endNode.row);\n  const dy = Math.abs(col - endNode.column);\n  const d = 1;\n  let ans;\n\n  if (heuristic === \"manhatten\") {\n    ans = d * (dx + dy);\n  }\n\n  if (heuristic === \"euclidean\") {\n    ans = d * Math.sqrt(dx * dx + dy * dy);\n  }\n\n  if (heuristic === \"octile\" || heuristic === \"chebyshev\") {\n    let d2 = diagDist;\n    ans = d * Math.max(dx, dy) + (d2 - d) * Math.min(dx, dy);\n  }\n\n  return ans;\n};\n\nconst getShortestPath = node => {\n  let shortestPath = [];\n\n  while (node !== null) {\n    shortestPath.unshift(node);\n    node = node.prevNode;\n    if (node) node.isShortestPath = true;\n  }\n\n  return shortestPath;\n};\n\nexport default astar;","map":{"version":3,"names":["PriorityQueue","astar","grid","startNode","endNode","heuristic","allowDiag","visitedNodes","shortestPath","diagDist","pq","comparator","a","b","f","h","forEach","row","node","g","Infinity","prevNode","column","queue","length","dequeue","col","isVisited","push","getShortestPath","n","j","i","r","c","isWall","dist","Math","abs","gNew","hNew","calculateHeuristic","fNew","dx","dy","d","ans","sqrt","d2","max","min","unshift","isShortestPath"],"sources":["/Users/amitkumar/PATHfinding Visualizer/PATHFinding Visualizer/PathfindingVisualizer/src/algorithms/astar.js"],"sourcesContent":["import PriorityQueue from \"js-priority-queue\";\n\nconst astar = (grid, startNode, endNode, heuristic, allowDiag) => {\n  let visitedNodes = [];\n  let shortestPath = [];\n  let diagDist = 1.414;\n  if (heuristic === \"chebyshev\") diagDist = 1;\n  let pq = new PriorityQueue({\n    comparator: function(a, b) {\n      //Tie-breaker\n      if (a.f === b.f) return a.h - b.h;\n      return a.f - b.f;\n    }\n  });\n  grid.forEach(row => {\n    row.forEach(node => {\n      //g : distance\n      node.g = Infinity;\n      //h : heuristic\n      node.h = Infinity;\n      //f = g + h\n      node.f = Infinity;\n      node.prevNode = null;\n    });\n  });\n  grid[startNode.row][startNode.column].g = 0;\n  grid[startNode.row][startNode.column].h = 0;\n  grid[startNode.row][startNode.column].f = 0;\n  pq.queue(grid[startNode.row][startNode.column]);\n  while (pq.length) {\n    const node = pq.dequeue();\n    const { row, col } = node;\n    grid[row][col].isVisited = true;\n    visitedNodes.push(node);\n    if (node.row === endNode.row && node.col === endNode.column) {\n      shortestPath = getShortestPath(node);\n      break;\n    }\n    const n = [\n      [1, 0],\n      [0, 1],\n      [-1, 0],\n      [0, -1]\n    ];\n    //with diag\n    if (allowDiag) n.push([-1, 1], [1, 1], [-1, -1], [1, -1]);\n    for (let j = 0; j < n.length; j++) {\n      const i = n[j];\n      const r = row + i[0];\n      const c = col + i[1];\n      if (\n        grid[r] &&\n        grid[r][c] &&\n        !grid[r][c].isVisited &&\n        (!grid[r][c].isWall || (r === endNode.row && c === endNode.column))\n      ) {\n        if (r === endNode.row && c === endNode.column) {\n          grid[r][c].isVisited = true;\n          grid[r][c].prevNode = grid[row][col];\n          shortestPath = getShortestPath(grid[r][c]);\n          return { visitedNodes, shortestPath };\n        }\n        const dist =\n          Math.abs(i[0]) === 1 && Math.abs(i[1]) === 1 ? diagDist : 1;\n        let gNew = grid[row][col].g + dist;\n        let hNew = calculateHeuristic(r, c, endNode, heuristic, diagDist);\n        let fNew = gNew + hNew;\n        if (grid[r][c].f > fNew) {\n          grid[r][c].g = gNew;\n          grid[r][c].h = hNew;\n          grid[r][c].f = fNew;\n          grid[r][c].prevNode = node;\n          pq.queue(grid[r][c]);\n        }\n      }\n    }\n  }\n  return { visitedNodes, shortestPath };\n};\n\nconst calculateHeuristic = (row, col, endNode, heuristic, diagDist) => {\n  const dx = Math.abs(row - endNode.row);\n  const dy = Math.abs(col - endNode.column);\n  const d = 1;\n  let ans;\n  if (heuristic === \"manhatten\") {\n    ans = d * (dx + dy);\n  }\n  if (heuristic === \"euclidean\") {\n    ans = d * Math.sqrt(dx * dx + dy * dy);\n  }\n  if (heuristic === \"octile\" || heuristic === \"chebyshev\") {\n    let d2 = diagDist;\n    ans = d * Math.max(dx, dy) + (d2 - d) * Math.min(dx, dy);\n  }\n  return ans;\n};\n\nconst getShortestPath = node => {\n  let shortestPath = [];\n  while (node !== null) {\n    shortestPath.unshift(node);\n    node = node.prevNode;\n    if (node) node.isShortestPath = true;\n  }\n  return shortestPath;\n};\n\nexport default astar;\n"],"mappings":"AAAA,OAAOA,aAAP,MAA0B,mBAA1B;;AAEA,MAAMC,KAAK,GAAG,CAACC,IAAD,EAAOC,SAAP,EAAkBC,OAAlB,EAA2BC,SAA3B,EAAsCC,SAAtC,KAAoD;EAChE,IAAIC,YAAY,GAAG,EAAnB;EACA,IAAIC,YAAY,GAAG,EAAnB;EACA,IAAIC,QAAQ,GAAG,KAAf;EACA,IAAIJ,SAAS,KAAK,WAAlB,EAA+BI,QAAQ,GAAG,CAAX;EAC/B,IAAIC,EAAE,GAAG,IAAIV,aAAJ,CAAkB;IACzBW,UAAU,EAAE,UAASC,CAAT,EAAYC,CAAZ,EAAe;MACzB;MACA,IAAID,CAAC,CAACE,CAAF,KAAQD,CAAC,CAACC,CAAd,EAAiB,OAAOF,CAAC,CAACG,CAAF,GAAMF,CAAC,CAACE,CAAf;MACjB,OAAOH,CAAC,CAACE,CAAF,GAAMD,CAAC,CAACC,CAAf;IACD;EALwB,CAAlB,CAAT;EAOAZ,IAAI,CAACc,OAAL,CAAaC,GAAG,IAAI;IAClBA,GAAG,CAACD,OAAJ,CAAYE,IAAI,IAAI;MAClB;MACAA,IAAI,CAACC,CAAL,GAASC,QAAT,CAFkB,CAGlB;;MACAF,IAAI,CAACH,CAAL,GAASK,QAAT,CAJkB,CAKlB;;MACAF,IAAI,CAACJ,CAAL,GAASM,QAAT;MACAF,IAAI,CAACG,QAAL,GAAgB,IAAhB;IACD,CARD;EASD,CAVD;EAWAnB,IAAI,CAACC,SAAS,CAACc,GAAX,CAAJ,CAAoBd,SAAS,CAACmB,MAA9B,EAAsCH,CAAtC,GAA0C,CAA1C;EACAjB,IAAI,CAACC,SAAS,CAACc,GAAX,CAAJ,CAAoBd,SAAS,CAACmB,MAA9B,EAAsCP,CAAtC,GAA0C,CAA1C;EACAb,IAAI,CAACC,SAAS,CAACc,GAAX,CAAJ,CAAoBd,SAAS,CAACmB,MAA9B,EAAsCR,CAAtC,GAA0C,CAA1C;EACAJ,EAAE,CAACa,KAAH,CAASrB,IAAI,CAACC,SAAS,CAACc,GAAX,CAAJ,CAAoBd,SAAS,CAACmB,MAA9B,CAAT;;EACA,OAAOZ,EAAE,CAACc,MAAV,EAAkB;IAChB,MAAMN,IAAI,GAAGR,EAAE,CAACe,OAAH,EAAb;IACA,MAAM;MAAER,GAAF;MAAOS;IAAP,IAAeR,IAArB;IACAhB,IAAI,CAACe,GAAD,CAAJ,CAAUS,GAAV,EAAeC,SAAf,GAA2B,IAA3B;IACApB,YAAY,CAACqB,IAAb,CAAkBV,IAAlB;;IACA,IAAIA,IAAI,CAACD,GAAL,KAAab,OAAO,CAACa,GAArB,IAA4BC,IAAI,CAACQ,GAAL,KAAatB,OAAO,CAACkB,MAArD,EAA6D;MAC3Dd,YAAY,GAAGqB,eAAe,CAACX,IAAD,CAA9B;MACA;IACD;;IACD,MAAMY,CAAC,GAAG,CACR,CAAC,CAAD,EAAI,CAAJ,CADQ,EAER,CAAC,CAAD,EAAI,CAAJ,CAFQ,EAGR,CAAC,CAAC,CAAF,EAAK,CAAL,CAHQ,EAIR,CAAC,CAAD,EAAI,CAAC,CAAL,CAJQ,CAAV,CATgB,CAehB;;IACA,IAAIxB,SAAJ,EAAewB,CAAC,CAACF,IAAF,CAAO,CAAC,CAAC,CAAF,EAAK,CAAL,CAAP,EAAgB,CAAC,CAAD,EAAI,CAAJ,CAAhB,EAAwB,CAAC,CAAC,CAAF,EAAK,CAAC,CAAN,CAAxB,EAAkC,CAAC,CAAD,EAAI,CAAC,CAAL,CAAlC;;IACf,KAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,CAAC,CAACN,MAAtB,EAA8BO,CAAC,EAA/B,EAAmC;MACjC,MAAMC,CAAC,GAAGF,CAAC,CAACC,CAAD,CAAX;MACA,MAAME,CAAC,GAAGhB,GAAG,GAAGe,CAAC,CAAC,CAAD,CAAjB;MACA,MAAME,CAAC,GAAGR,GAAG,GAAGM,CAAC,CAAC,CAAD,CAAjB;;MACA,IACE9B,IAAI,CAAC+B,CAAD,CAAJ,IACA/B,IAAI,CAAC+B,CAAD,CAAJ,CAAQC,CAAR,CADA,IAEA,CAAChC,IAAI,CAAC+B,CAAD,CAAJ,CAAQC,CAAR,EAAWP,SAFZ,KAGC,CAACzB,IAAI,CAAC+B,CAAD,CAAJ,CAAQC,CAAR,EAAWC,MAAZ,IAAuBF,CAAC,KAAK7B,OAAO,CAACa,GAAd,IAAqBiB,CAAC,KAAK9B,OAAO,CAACkB,MAH3D,CADF,EAKE;QACA,IAAIW,CAAC,KAAK7B,OAAO,CAACa,GAAd,IAAqBiB,CAAC,KAAK9B,OAAO,CAACkB,MAAvC,EAA+C;UAC7CpB,IAAI,CAAC+B,CAAD,CAAJ,CAAQC,CAAR,EAAWP,SAAX,GAAuB,IAAvB;UACAzB,IAAI,CAAC+B,CAAD,CAAJ,CAAQC,CAAR,EAAWb,QAAX,GAAsBnB,IAAI,CAACe,GAAD,CAAJ,CAAUS,GAAV,CAAtB;UACAlB,YAAY,GAAGqB,eAAe,CAAC3B,IAAI,CAAC+B,CAAD,CAAJ,CAAQC,CAAR,CAAD,CAA9B;UACA,OAAO;YAAE3B,YAAF;YAAgBC;UAAhB,CAAP;QACD;;QACD,MAAM4B,IAAI,GACRC,IAAI,CAACC,GAAL,CAASN,CAAC,CAAC,CAAD,CAAV,MAAmB,CAAnB,IAAwBK,IAAI,CAACC,GAAL,CAASN,CAAC,CAAC,CAAD,CAAV,MAAmB,CAA3C,GAA+CvB,QAA/C,GAA0D,CAD5D;QAEA,IAAI8B,IAAI,GAAGrC,IAAI,CAACe,GAAD,CAAJ,CAAUS,GAAV,EAAeP,CAAf,GAAmBiB,IAA9B;QACA,IAAII,IAAI,GAAGC,kBAAkB,CAACR,CAAD,EAAIC,CAAJ,EAAO9B,OAAP,EAAgBC,SAAhB,EAA2BI,QAA3B,CAA7B;QACA,IAAIiC,IAAI,GAAGH,IAAI,GAAGC,IAAlB;;QACA,IAAItC,IAAI,CAAC+B,CAAD,CAAJ,CAAQC,CAAR,EAAWpB,CAAX,GAAe4B,IAAnB,EAAyB;UACvBxC,IAAI,CAAC+B,CAAD,CAAJ,CAAQC,CAAR,EAAWf,CAAX,GAAeoB,IAAf;UACArC,IAAI,CAAC+B,CAAD,CAAJ,CAAQC,CAAR,EAAWnB,CAAX,GAAeyB,IAAf;UACAtC,IAAI,CAAC+B,CAAD,CAAJ,CAAQC,CAAR,EAAWpB,CAAX,GAAe4B,IAAf;UACAxC,IAAI,CAAC+B,CAAD,CAAJ,CAAQC,CAAR,EAAWb,QAAX,GAAsBH,IAAtB;UACAR,EAAE,CAACa,KAAH,CAASrB,IAAI,CAAC+B,CAAD,CAAJ,CAAQC,CAAR,CAAT;QACD;MACF;IACF;EACF;;EACD,OAAO;IAAE3B,YAAF;IAAgBC;EAAhB,CAAP;AACD,CA5ED;;AA8EA,MAAMiC,kBAAkB,GAAG,CAACxB,GAAD,EAAMS,GAAN,EAAWtB,OAAX,EAAoBC,SAApB,EAA+BI,QAA/B,KAA4C;EACrE,MAAMkC,EAAE,GAAGN,IAAI,CAACC,GAAL,CAASrB,GAAG,GAAGb,OAAO,CAACa,GAAvB,CAAX;EACA,MAAM2B,EAAE,GAAGP,IAAI,CAACC,GAAL,CAASZ,GAAG,GAAGtB,OAAO,CAACkB,MAAvB,CAAX;EACA,MAAMuB,CAAC,GAAG,CAAV;EACA,IAAIC,GAAJ;;EACA,IAAIzC,SAAS,KAAK,WAAlB,EAA+B;IAC7ByC,GAAG,GAAGD,CAAC,IAAIF,EAAE,GAAGC,EAAT,CAAP;EACD;;EACD,IAAIvC,SAAS,KAAK,WAAlB,EAA+B;IAC7ByC,GAAG,GAAGD,CAAC,GAAGR,IAAI,CAACU,IAAL,CAAUJ,EAAE,GAAGA,EAAL,GAAUC,EAAE,GAAGA,EAAzB,CAAV;EACD;;EACD,IAAIvC,SAAS,KAAK,QAAd,IAA0BA,SAAS,KAAK,WAA5C,EAAyD;IACvD,IAAI2C,EAAE,GAAGvC,QAAT;IACAqC,GAAG,GAAGD,CAAC,GAAGR,IAAI,CAACY,GAAL,CAASN,EAAT,EAAaC,EAAb,CAAJ,GAAuB,CAACI,EAAE,GAAGH,CAAN,IAAWR,IAAI,CAACa,GAAL,CAASP,EAAT,EAAaC,EAAb,CAAxC;EACD;;EACD,OAAOE,GAAP;AACD,CAhBD;;AAkBA,MAAMjB,eAAe,GAAGX,IAAI,IAAI;EAC9B,IAAIV,YAAY,GAAG,EAAnB;;EACA,OAAOU,IAAI,KAAK,IAAhB,EAAsB;IACpBV,YAAY,CAAC2C,OAAb,CAAqBjC,IAArB;IACAA,IAAI,GAAGA,IAAI,CAACG,QAAZ;IACA,IAAIH,IAAJ,EAAUA,IAAI,CAACkC,cAAL,GAAsB,IAAtB;EACX;;EACD,OAAO5C,YAAP;AACD,CARD;;AAUA,eAAeP,KAAf"},"metadata":{},"sourceType":"module"}