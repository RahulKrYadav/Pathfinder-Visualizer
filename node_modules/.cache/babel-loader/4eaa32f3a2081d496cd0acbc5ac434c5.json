{"ast":null,"code":"import PriorityQueue from \"js-priority-queue\";\n\nconst dijkstra = (grid, startNode, endNode, allowDiag) => {\n  let visitedNodes = [];\n  let shortestPath = [];\n  let pq = new PriorityQueue({\n    comparator: function (a, b) {\n      return a.distance - b.distance;\n    }\n  });\n  grid.forEach(row => row.forEach(node => {\n    if (node.row === startNode.row && node.col === startNode.column) {\n      node.distance = 0;\n    } else node.distance = Infinity;\n\n    node.prevNode = null;\n  }));\n  pq.queue(grid[startNode.row][startNode.column]);\n\n  while (pq.length) {\n    const node = pq.dequeue();\n    const {\n      row,\n      col\n    } = node;\n    if (grid[row][col].isVisited) continue;\n    grid[row][col].isVisited = true;\n    visitedNodes.push(node); //if (node.distance === Infinity) break;\n\n    const n = [[1, 0], [0, 1], [-1, 0], [0, -1]]; //with diag\n\n    if (allowDiag) n.push([-1, 1], [1, 1], [-1, -1], [1, -1]);\n\n    for (let j = 0; j < n.length; j++) {\n      const i = n[j];\n      const r = row + i[0];\n      const c = col + i[1];\n\n      if (grid[r] && grid[r][c] && !grid[r][c].isVisited && (!grid[r][c].isWall || r === endNode.row && c === endNode.column)) {\n        if (r === endNode.row && c === endNode.column) {\n          grid[r][c].isVisited = true;\n          grid[r][c].prevNode = grid[row][col];\n          shortestPath = getShortestPath(grid[r][c]);\n          return {\n            visitedNodes,\n            shortestPath\n          };\n        }\n\n        const dist = Math.abs(i[0]) === 1 && Math.abs(i[1]) === 1 ? 1.4 : 1;\n\n        if (node.distance + dist < grid[r][c].distance) {\n          grid[r][c].prevNode = node;\n          grid[r][c].distance = node.distance + dist;\n        }\n\n        pq.queue(grid[r][c]);\n      }\n    }\n  }\n\n  return {\n    visitedNodes,\n    shortestPath\n  };\n};\n\nconst getShortestPath = node => {\n  let shortestPath = [];\n\n  while (node !== null) {\n    shortestPath.unshift(node);\n    node = node.prevNode;\n    if (node) node.isShortestPath = true;\n  }\n\n  return shortestPath;\n};\n\nexport default dijkstra;","map":{"version":3,"names":["PriorityQueue","dijkstra","grid","startNode","endNode","allowDiag","visitedNodes","shortestPath","pq","comparator","a","b","distance","forEach","row","node","col","column","Infinity","prevNode","queue","length","dequeue","isVisited","push","n","j","i","r","c","isWall","getShortestPath","dist","Math","abs","unshift","isShortestPath"],"sources":["/Users/amitkumar/Documents/RKY/PROJECTS/Project@PathfinderVisualizer/src/algorithms/dijkstra.js"],"sourcesContent":["import PriorityQueue from \"js-priority-queue\";\n\nconst dijkstra = (grid, startNode, endNode, allowDiag) => {\n  let visitedNodes = [];\n  let shortestPath = [];\n  let pq = new PriorityQueue({\n    comparator: function(a, b) {\n      return a.distance - b.distance;\n    }\n  });\n  grid.forEach(row =>\n    row.forEach(node => {\n      if (node.row === startNode.row && node.col === startNode.column) {\n        node.distance = 0;\n      } else node.distance = Infinity;\n      node.prevNode = null;\n    })\n  );\n  pq.queue(grid[startNode.row][startNode.column]);\n  while (pq.length) {\n    const node = pq.dequeue();\n    const { row, col } = node;\n    if (grid[row][col].isVisited) continue;\n    grid[row][col].isVisited = true;\n    visitedNodes.push(node);\n    //if (node.distance === Infinity) break;\n    const n = [\n      [1, 0],\n      [0, 1],\n      [-1, 0],\n      [0, -1]\n    ];\n    //with diag\n    if (allowDiag) n.push([-1, 1], [1, 1], [-1, -1], [1, -1]);\n    for (let j = 0; j < n.length; j++) {\n      const i = n[j];\n      const r = row + i[0];\n      const c = col + i[1];\n      if (\n        grid[r] &&\n        grid[r][c] &&\n        !grid[r][c].isVisited &&\n        (!grid[r][c].isWall || (r === endNode.row && c === endNode.column))\n      ) {\n        if (r === endNode.row && c === endNode.column) {\n          grid[r][c].isVisited = true;\n          grid[r][c].prevNode = grid[row][col];\n          shortestPath = getShortestPath(grid[r][c]);\n          return { visitedNodes, shortestPath };\n        }\n        const dist = Math.abs(i[0]) === 1 && Math.abs(i[1]) === 1 ? 1.4 : 1;\n        if (node.distance + dist < grid[r][c].distance) {\n          grid[r][c].prevNode = node;\n          grid[r][c].distance = node.distance + dist;\n        }\n        pq.queue(grid[r][c]);\n      }\n    }\n  }\n  return { visitedNodes, shortestPath };\n};\n\nconst getShortestPath = node => {\n  let shortestPath = [];\n  while (node !== null) {\n    shortestPath.unshift(node);\n    node = node.prevNode;\n    if (node) node.isShortestPath = true;\n  }\n  return shortestPath;\n};\n\nexport default dijkstra;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}