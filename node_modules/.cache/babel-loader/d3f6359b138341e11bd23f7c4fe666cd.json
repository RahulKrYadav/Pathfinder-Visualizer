{"ast":null,"code":"var _jsxFileName = \"/Users/amitkumar/Documents/RKY/PROJECTS/PATHFIND-1/src/components/Grid.js\";\nimport React from \"react\";\nimport Node from \"./Node\";\nimport dijkstra from \"../algorithms/dijkstra\";\nimport astar from \"../algorithms/astar\";\nimport jumpPointSearch from \"../algorithms/jumpPointSearch\";\nimport kruskal from \"../mazeGen/kruskall\";\nimport recursiveDivision from \"../mazeGen/recursiveDivison\";\nimport prim from \"../mazeGen/Prim\";\nimport Card from \"@material-ui/core/Card\";\nimport { withStyles } from \"@material-ui/core/styles\";\nimport { connect } from \"react-redux\";\nimport { setAnimating, setVisited, setShortest } from \"../actions\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nlet startNode = {\n  row: 20,\n  column: 4\n};\nlet endNode = {\n  row: 20,\n  column: 27\n};\nlet selectStart = false;\nlet selectEnd = false;\nlet selectWall = false;\nlet selectRemoveWall = false;\nlet isAnimated = false;\nconst startNodeClass = \"start-node\";\nconst endNodeClass = \"end-node\";\nconst wallClass = \"wall\";\nconst GridContainer = withStyles({\n  root: {\n    width: \"100%\",\n    padding: \"1vw\",\n    marginRight: \"1vw\"\n  }\n})(Card);\n_c = GridContainer;\n\nclass TGrid extends React.Component {\n  constructor(props) {\n    var _this;\n\n    super(props);\n    _this = this;\n\n    this.nodes = () => {\n      let nodes = [];\n\n      for (let i = 0; i < this.props.rows; i++) {\n        let nodeRow = [];\n\n        for (let j = 0; j < this.props.columns; j++) nodeRow.push( /*#__PURE__*/_jsxDEV(Node, {\n          startNodeClass: startNodeClass,\n          endNodeClass: endNodeClass,\n          wallClass: wallClass,\n          row: this.state.grid[i][j].row,\n          column: this.state.grid[i][j].col,\n          isStart: this.state.grid[i][j].isStart,\n          isEnd: this.state.grid[i][j].isEnd,\n          isVisited: this.state.grid[i][j].isVisited,\n          isWall: this.state.grid[i][j].isWall,\n          isShortestPath: this.state.grid[i][j].isShortestPath,\n          onMouseClick: this.onMouseClick,\n          onMouseEnterAndLeave: this.onMouseEnterAndLeave,\n          ref: this.nodeRefs[i][j]\n        }, i.toString() + \"-\" + j.toString(), false, {\n          fileName: _jsxFileName,\n          lineNumber: 80,\n          columnNumber: 11\n        }, this));\n\n        nodes.push( /*#__PURE__*/_jsxDEV(\"tr\", {\n          children: nodeRow\n        }, i, false, {\n          fileName: _jsxFileName,\n          lineNumber: 97,\n          columnNumber: 18\n        }, this));\n      }\n\n      return nodes;\n    };\n\n    this.setGrid = async function () {\n      let grid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.getInitGrid();\n\n      if (selectEnd) {\n        selectEnd = false;\n\n        _this.changeGridEndNode(endNode.row, endNode.column, grid);\n      }\n\n      if (selectStart) {\n        selectStart = false;\n\n        _this.changeGridStartNode(startNode.row, startNode.column, grid);\n      }\n\n      if (selectWall) {\n        selectWall = false;\n        await _this.setState({});\n      }\n\n      _this.setState({\n        grid\n      });\n    };\n\n    this.getInitGrid = () => {\n      let grid = [];\n\n      for (let i = 0; i < this.props.rows; i++) {\n        let row = [];\n\n        for (let j = 0; j < this.props.columns; j++) row.push(this.getNode(i, j));\n\n        grid.push(row);\n      }\n\n      return grid;\n    };\n\n    this.getNode = (row, col) => {\n      return {\n        row,\n        col,\n        isStart: row === startNode.row && col === startNode.column,\n        isEnd: row === endNode.row && col === endNode.column,\n        isVisited: false,\n        isShortestPath: false,\n        isWall: false\n      };\n    };\n\n    this.onMouseClick = async (row, column) => {\n      if (this.props.anim) return;\n\n      if (selectStart) {\n        if (row !== endNode.row || column !== endNode.column) {\n          selectStart = false;\n          this.changeGridStartNode(row, column);\n        }\n      } else if (row === startNode.row && column === startNode.column && !selectEnd) {\n        selectStart = true;\n        if (this.state.grid[row][column].isWall) this.nodeRefs[row][column].current.classList.add(wallClass);\n      } else if (selectEnd) {\n        if (row !== startNode.row || column !== startNode.column) {\n          selectEnd = false;\n          this.changeGridEndNode(row, column);\n        }\n      } else if (row === endNode.row && column === endNode.column && !selectStart) {\n        selectEnd = true;\n        if (this.state.grid[row][column].isWall) this.nodeRefs[row][column].current.classList.add(wallClass);\n      } else if (selectWall) {\n        selectWall = false;\n        await this.setGrid(this.state.grid);\n      } else if (this.state.grid[row][column].isWall) {\n        selectRemoveWall = true;\n        this.nodeRefs[row][column].current.classList.remove(wallClass);\n        let grid = this.state.grid;\n        grid[row][column].isWall = false;\n        if (isAnimated) this.visualizeRealTime(startNode, endNode);\n      } else if (selectRemoveWall) {\n        selectRemoveWall = false;\n        await this.setGrid(this.state.grid);\n      } else {\n        selectWall = true;\n        this.nodeRefs[row][column].current.classList.add(wallClass);\n        let grid = this.state.grid;\n        grid[row][column].isWall = true;\n        if (isAnimated) this.visualizeRealTime(startNode, endNode);\n      }\n    };\n\n    this.onMouseEnterAndLeave = (row, column) => {\n      //Just changing the class using refs.\n      if (selectStart) {\n        if (row !== endNode.row || column !== endNode.column) {\n          this.nodeRefs[row][column].current.classList.toggle(startNodeClass);\n          if (isAnimated) this.visualizeRealTime({\n            row,\n            column\n          }, endNode);\n        }\n      } else if (selectEnd) {\n        if (row !== startNode.row || column !== startNode.column) {\n          this.nodeRefs[row][column].current.classList.toggle(endNodeClass);\n          if (isAnimated) this.visualizeRealTime(startNode, {\n            row,\n            column\n          });\n        }\n      } else if (selectWall) {\n        if ((row !== endNode.row || column !== endNode.column) && (row !== startNode.row || column !== startNode.column)) {\n          this.nodeRefs[row][column].current.classList.add(wallClass);\n          let grid = this.state.grid;\n          grid[row][column].isWall = true;\n          if (isAnimated) this.visualizeRealTime(startNode, endNode);\n        }\n      } else if (selectRemoveWall) {\n        if ((row !== endNode.row || column !== endNode.column) && (row !== startNode.row || column !== startNode.column)) {\n          this.nodeRefs[row][column].current.classList.remove(wallClass);\n          let grid = this.state.grid;\n          grid[row][column].isWall = false;\n          if (isAnimated) this.visualizeRealTime(startNode, endNode);\n        }\n      }\n    };\n\n    this.getRefs = () => {\n      let refs = [];\n\n      for (let i = 0; i < this.props.rows; i++) {\n        let rowRef = [];\n\n        for (let j = 0; j < this.props.columns; j++) rowRef.push( /*#__PURE__*/React.createRef());\n\n        refs.push(rowRef);\n      }\n\n      return refs;\n    };\n\n    this.changeGridStartNode = function (row, column) {\n      let grid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _this.state.grid;\n      grid[startNode.row][startNode.column].isStart = false;\n      startNode = {\n        row,\n        column\n      };\n      grid[startNode.row][startNode.column].isStart = true;\n\n      _this.nodeRefs[row][column].current.classList.add(startNodeClass);\n\n      _this.setGrid(grid);\n    };\n\n    this.changeGridEndNode = function (row, column) {\n      let grid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _this.state.grid;\n      grid[endNode.row][endNode.column].isEnd = false;\n      endNode = {\n        row,\n        column\n      };\n      grid[endNode.row][endNode.column].isEnd = true;\n\n      _this.nodeRefs[row][column].current.classList.add(endNodeClass);\n\n      _this.setGrid(grid);\n    };\n\n    this.clearVisited = grid => {\n      this.props.setVisited(0);\n      this.props.setShortest(0);\n      grid.forEach(row => row.forEach(node => {\n        node.isShortestPath = false;\n        node.isVisited = false;\n        this.nodeRefs[node.row][node.col].current.classList.remove(\"visited\");\n        this.nodeRefs[node.row][node.col].current.classList.remove(\"shortest-path\");\n        this.nodeRefs[node.row][node.col].current.classList.remove(\"visited-anim\");\n        this.nodeRefs[node.row][node.col].current.classList.remove(\"shortest-path-anim\");\n      }));\n    };\n\n    this.clearGrid = () => {\n      isAnimated = false;\n      this.props.setVisited(0);\n      this.props.setShortest(0);\n      this.setGrid();\n    };\n\n    this.visualize = async () => {\n      this.props.setAnimating(true);\n      let grid = this.state.grid;\n      await this.setGrid(grid);\n      this.clearVisited(grid);\n      const response = await this.getResponseFromAlgo(grid, startNode, endNode);\n      const {\n        visitedNodes,\n        shortestPath\n      } = response;\n      visitedNodes.shift();\n      shortestPath.shift();\n      shortestPath.pop();\n\n      if (visitedNodes.length === 0 && shortestPath.length === 0) {\n        this.props.setAnimating(false);\n        this.setGrid(grid);\n        return;\n      }\n\n      this.animate(visitedNodes, shortestPath, grid);\n    };\n\n    this.getResponseFromAlgo = (grid, sn, en) => {\n      let response;\n\n      switch (this.props.algo) {\n        case 0:\n          response = dijkstra(grid, sn, en, this.props.diag);\n          break;\n\n        case 1:\n          response = astar(grid, sn, en, this.props.heuristic[1], this.props.diag);\n          break;\n\n        case 2:\n          response = jumpPointSearch(grid, sn, en);\n          break;\n\n        default:\n          break;\n      }\n\n      return response;\n    };\n\n    this.animate = async (visitedNodes, shortestPath, grid) => {\n      let i = 0,\n          j = 0;\n\n      const animateVisitedNodes = async () => {\n        if (i === visitedNodes.length) {\n          if (shortestPath.length) requestAnimationFrame(animateShortestPath);else {\n            isAnimated = true;\n            this.props.setAnimating(false);\n            this.setGrid(grid);\n          }\n          return;\n        }\n\n        const {\n          row,\n          col\n        } = visitedNodes[i];\n        this.nodeRefs[row][col].current.classList.add(\"visited-anim\");\n        ++i;\n        this.props.setVisited(i);\n        requestAnimationFrame(animateVisitedNodes);\n      };\n\n      const animateShortestPath = () => {\n        if (j === shortestPath.length) {\n          isAnimated = true;\n          this.props.setAnimating(false);\n          this.setGrid(grid);\n          return;\n        }\n\n        const {\n          row,\n          col\n        } = shortestPath[j];\n        this.nodeRefs[row][col].current.classList.add(\"shortest-path-anim\");\n        ++j;\n        this.props.setShortest(j);\n        requestAnimationFrame(animateShortestPath);\n      };\n\n      await requestAnimationFrame(animateVisitedNodes);\n    };\n\n    this.visualizeRealTime = (sn, en) => {\n      let grid = this.state.grid;\n      this.clearVisited(grid);\n      const {\n        visitedNodes,\n        shortestPath\n      } = this.getResponseFromAlgo(grid, sn, en);\n      this.props.setVisited(visitedNodes.length);\n      this.props.setShortest(shortestPath.length);\n      visitedNodes.shift();\n      shortestPath.shift();\n      shortestPath.pop();\n      visitedNodes.forEach(node => {\n        this.nodeRefs[node.row][node.col].current.classList.add(\"visited\");\n      });\n      shortestPath.forEach(node => {\n        this.nodeRefs[node.row][node.col].current.classList.add(\"shortest-path\");\n      });\n      return {\n        visitedNodes,\n        shortestPath\n      };\n    };\n\n    this.visualizeMaze = async () => {\n      await this.clearGrid();\n      let grid = this.state.grid;\n\n      if (!this.props.animMaze) {\n        this.getResponseFromMaze(grid, this.props.maze);\n        await this.setGrid(grid);\n      } else {\n        this.props.setAnimating(true);\n        await this.setGrid(grid);\n        const {\n          addedWalls,\n          removedWalls,\n          animAddedWalls\n        } = this.getResponseFromMaze(grid);\n        this.animateMaze(addedWalls, removedWalls, grid, animAddedWalls);\n      }\n    };\n\n    this.getResponseFromMaze = grid => {\n      switch (this.props.maze) {\n        case 0:\n          return kruskal(grid, this.props.rows, this.props.columns);\n\n        case 1:\n          return prim(grid, this.props.rows, this.props.columns);\n\n        case 2:\n          return recursiveDivision(grid, this.props.rows, this.props.columns);\n\n        default:\n          break;\n      }\n    };\n\n    this.animateMaze = (addedWalls, removedWalls, grid, animAddedWalls) => {\n      let i = 0;\n\n      const animateAddedWalls = () => {\n        if (i === addedWalls.length) {\n          if (removedWalls.length) requestAnimationFrame(animateRemovedWalls);else {\n            this.props.setAnimating(false);\n            this.setGrid(grid);\n          }\n          return;\n        }\n\n        const {\n          row,\n          col\n        } = addedWalls[i];\n        this.nodeRefs[row][col].current.classList.add(wallClass);\n        ++i;\n        requestAnimationFrame(animateAddedWalls);\n      };\n\n      let j = 0;\n\n      const animateRemovedWalls = () => {\n        if (j === removedWalls.length) {\n          this.props.setAnimating(false);\n          this.setGrid(grid);\n          return;\n        }\n\n        const {\n          row,\n          col\n        } = removedWalls[j];\n        this.nodeRefs[row][col].current.classList.remove(wallClass);\n        ++j;\n        requestAnimationFrame(animateRemovedWalls);\n      };\n\n      const showAddedWalls = () => {\n        addedWalls.forEach(node => this.nodeRefs[node.row][node.col].current.classList.add(wallClass));\n      };\n\n      if (animAddedWalls) {\n        requestAnimationFrame(animateAddedWalls);\n      } else {\n        showAddedWalls();\n        requestAnimationFrame(animateRemovedWalls);\n      }\n    };\n\n    this.state = {\n      grid: []\n    };\n    this.nodeRefs = this.getRefs();\n    this.gridRef = /*#__PURE__*/React.createRef();\n  }\n\n  async componentDidMount() {\n    await this.setGrid();\n    this.gridRef.current.style.height = `${this.gridRef.current.offsetWidth / this.props.columns * this.props.rows}px`;\n    window.addEventListener(\"resize\", e => {\n      this.gridRef.current.style.height = `${this.gridRef.current.offsetWidth / this.props.columns * this.props.rows}px`;\n    });\n  }\n\n  render() {\n    if (isAnimated) {\n      const response = this.visualizeRealTime(startNode, endNode);\n      this.props.setVisited(response.visitedNodes.length);\n      this.props.setShortest(response.shortestPath.length);\n    }\n\n    if (this.state.grid.length === 0) return /*#__PURE__*/_jsxDEV(\"div\", {\n      children: \"Loading...\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 64,\n      columnNumber: 46\n    }, this);\n    return /*#__PURE__*/_jsxDEV(GridContainer, {\n      ref: this.gridRef,\n      children: /*#__PURE__*/_jsxDEV(\"table\", {\n        className: \"grid\",\n        children: /*#__PURE__*/_jsxDEV(\"tbody\", {\n          children: this.nodes()\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 68,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 67,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 66,\n      columnNumber: 7\n    }, this);\n  }\n\n}\n\nconst mapStateToProps = state => {\n  return {\n    algo: state.algo,\n    diag: state.diag,\n    heuristic: state.heuristic,\n    maze: state.maze,\n    animMaze: state.animMaze,\n    anim: state.anim\n  };\n};\n\nexport default connect(mapStateToProps, {\n  setAnimating,\n  setVisited,\n  setShortest\n}, null, {\n  forwardRef: true\n})(TGrid);\n\nvar _c;\n\n$RefreshReg$(_c, \"GridContainer\");","map":{"version":3,"names":["React","Node","dijkstra","astar","jumpPointSearch","kruskal","recursiveDivision","prim","Card","withStyles","connect","setAnimating","setVisited","setShortest","startNode","row","column","endNode","selectStart","selectEnd","selectWall","selectRemoveWall","isAnimated","startNodeClass","endNodeClass","wallClass","GridContainer","root","width","padding","marginRight","TGrid","Component","constructor","props","nodes","i","rows","nodeRow","j","columns","push","state","grid","col","isStart","isEnd","isVisited","isWall","isShortestPath","onMouseClick","onMouseEnterAndLeave","nodeRefs","toString","setGrid","getInitGrid","changeGridEndNode","changeGridStartNode","setState","getNode","anim","current","classList","add","remove","visualizeRealTime","toggle","getRefs","refs","rowRef","createRef","clearVisited","forEach","node","clearGrid","visualize","response","getResponseFromAlgo","visitedNodes","shortestPath","shift","pop","length","animate","sn","en","algo","diag","heuristic","animateVisitedNodes","requestAnimationFrame","animateShortestPath","visualizeMaze","animMaze","getResponseFromMaze","maze","addedWalls","removedWalls","animAddedWalls","animateMaze","animateAddedWalls","animateRemovedWalls","showAddedWalls","gridRef","componentDidMount","style","height","offsetWidth","window","addEventListener","e","render","mapStateToProps","forwardRef"],"sources":["/Users/amitkumar/Documents/RKY/PROJECTS/PATHFIND-1/src/components/Grid.js"],"sourcesContent":["import React from \"react\";\nimport Node from \"./Node\";\nimport dijkstra from \"../algorithms/dijkstra\";\nimport astar from \"../algorithms/astar\";\nimport jumpPointSearch from \"../algorithms/jumpPointSearch\";\nimport kruskal from \"../mazeGen/kruskall\";\nimport recursiveDivision from \"../mazeGen/recursiveDivison\";\nimport prim from \"../mazeGen/Prim\";\nimport Card from \"@material-ui/core/Card\";\nimport { withStyles } from \"@material-ui/core/styles\";\nimport { connect } from \"react-redux\";\nimport { setAnimating, setVisited, setShortest } from \"../actions\";\n\n\n\nlet startNode = { row: 20, column: 4 };\nlet endNode = { row: 20, column: 27 };\nlet selectStart = false;\nlet selectEnd = false;\nlet selectWall = false;\nlet selectRemoveWall = false;\nlet isAnimated = false;\n\nconst startNodeClass = \"start-node\";\n\nconst endNodeClass = \"end-node\";\nconst wallClass = \"wall\";\n\nconst GridContainer = withStyles({\n  root: {\n    width: \"100%\",\n    padding: \"1vw\",\n    marginRight: \"1vw\"\n  }\n})(Card);\n\nclass TGrid extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      grid: []\n    };\n    this.nodeRefs = this.getRefs();\n    this.gridRef = React.createRef();\n  }\n  async componentDidMount() {\n    await this.setGrid();\n    this.gridRef.current.style.height = `${(this.gridRef.current.offsetWidth /\n      this.props.columns) *\n      this.props.rows}px`;\n    window.addEventListener(\"resize\", e => {\n      this.gridRef.current.style.height = `${(this.gridRef.current.offsetWidth /\n        this.props.columns) *\n        this.props.rows}px`;\n    });\n  }\n\n  render() {\n    if (isAnimated) {\n      const response = this.visualizeRealTime(startNode, endNode);\n      this.props.setVisited(response.visitedNodes.length);\n      this.props.setShortest(response.shortestPath.length);\n    }\n    if (this.state.grid.length === 0) return <div>Loading...</div>;\n    return (\n      <GridContainer ref={this.gridRef}>\n        <table className=\"grid\">\n          <tbody>{this.nodes()}</tbody>\n        </table>\n      </GridContainer>\n    );\n  }\n\n  nodes = () => {\n    let nodes = [];\n    for (let i = 0; i < this.props.rows; i++) {\n      let nodeRow = [];\n      for (let j = 0; j < this.props.columns; j++)\n        nodeRow.push(\n          <Node\n            key={i.toString() + \"-\" + j.toString()}\n            startNodeClass={startNodeClass}\n            endNodeClass={endNodeClass}\n            wallClass={wallClass}\n            row={this.state.grid[i][j].row}\n            column={this.state.grid[i][j].col}\n            isStart={this.state.grid[i][j].isStart}\n            isEnd={this.state.grid[i][j].isEnd}\n            isVisited={this.state.grid[i][j].isVisited}\n            isWall={this.state.grid[i][j].isWall}\n            isShortestPath={this.state.grid[i][j].isShortestPath}\n            onMouseClick={this.onMouseClick}\n            onMouseEnterAndLeave={this.onMouseEnterAndLeave}\n            ref={this.nodeRefs[i][j]}\n          />\n        );\n      nodes.push(<tr key={i}>{nodeRow}</tr>);\n    }\n    return nodes;\n  };\n  setGrid = async (grid = this.getInitGrid()) => {\n    if (selectEnd) {\n      selectEnd = false;\n      this.changeGridEndNode(endNode.row, endNode.column, grid);\n    }\n    if (selectStart) {\n      selectStart = false;\n      this.changeGridStartNode(startNode.row, startNode.column, grid);\n    }\n    if (selectWall) {\n      selectWall = false;\n      await this.setState({});\n    }\n    this.setState({ grid });\n  };\n\n  getInitGrid = () => {\n    let grid = [];\n    for (let i = 0; i < this.props.rows; i++) {\n      let row = [];\n      for (let j = 0; j < this.props.columns; j++) row.push(this.getNode(i, j));\n      grid.push(row);\n    }\n    return grid;\n  };\n  getNode = (row, col) => {\n    return {\n      row,\n      col,\n      isStart: row === startNode.row && col === startNode.column,\n      isEnd: row === endNode.row && col === endNode.column,\n      isVisited: false,\n      isShortestPath: false,\n      isWall: false\n    };\n  };\n  onMouseClick = async (row, column) => {\n    if (this.props.anim) return;\n    if (selectStart) {\n      if (row !== endNode.row || column !== endNode.column) {\n        selectStart = false;\n        this.changeGridStartNode(row, column);\n      }\n    } else if (\n      row === startNode.row &&\n      column === startNode.column &&\n      !selectEnd\n    ) {\n      selectStart = true;\n      if (this.state.grid[row][column].isWall)\n        this.nodeRefs[row][column].current.classList.add(wallClass);\n    } else if (selectEnd) {\n      if (row !== startNode.row || column !== startNode.column) {\n        selectEnd = false;\n        this.changeGridEndNode(row, column);\n      }\n    } else if (\n      row === endNode.row &&\n      column === endNode.column &&\n      !selectStart\n    ) {\n      selectEnd = true;\n      if (this.state.grid[row][column].isWall)\n        this.nodeRefs[row][column].current.classList.add(wallClass);\n    } else if (selectWall) {\n      selectWall = false;\n      await this.setGrid(this.state.grid);\n    } else if (this.state.grid[row][column].isWall) {\n      selectRemoveWall = true;\n      this.nodeRefs[row][column].current.classList.remove(wallClass);\n      let grid = this.state.grid;\n      grid[row][column].isWall = false;\n      if (isAnimated) this.visualizeRealTime(startNode, endNode);\n    } else if (selectRemoveWall) {\n      selectRemoveWall = false;\n      await this.setGrid(this.state.grid);\n    } else {\n      selectWall = true;\n      this.nodeRefs[row][column].current.classList.add(wallClass);\n      let grid = this.state.grid;\n      grid[row][column].isWall = true;\n      if (isAnimated) this.visualizeRealTime(startNode, endNode);\n    }\n  };\n  onMouseEnterAndLeave = (row, column) => {\n    //Just changing the class using refs.\n    if (selectStart) {\n      if (row !== endNode.row || column !== endNode.column) {\n        this.nodeRefs[row][column].current.classList.toggle(startNodeClass);\n        if (isAnimated) this.visualizeRealTime({ row, column }, endNode);\n      }\n    } else if (selectEnd) {\n      if (row !== startNode.row || column !== startNode.column) {\n        this.nodeRefs[row][column].current.classList.toggle(endNodeClass);\n        if (isAnimated) this.visualizeRealTime(startNode, { row, column });\n      }\n    } else if (selectWall) {\n      if (\n        (row !== endNode.row || column !== endNode.column) &&\n        (row !== startNode.row || column !== startNode.column)\n      ) {\n        this.nodeRefs[row][column].current.classList.add(wallClass);\n        let grid = this.state.grid;\n        grid[row][column].isWall = true;\n        if (isAnimated) this.visualizeRealTime(startNode, endNode);\n      }\n    } else if (selectRemoveWall) {\n      if (\n        (row !== endNode.row || column !== endNode.column) &&\n        (row !== startNode.row || column !== startNode.column)\n      ) {\n        this.nodeRefs[row][column].current.classList.remove(wallClass);\n        let grid = this.state.grid;\n        grid[row][column].isWall = false;\n        if (isAnimated) this.visualizeRealTime(startNode, endNode);\n      }\n    }\n  };\n  getRefs = () => {\n    let refs = [];\n    for (let i = 0; i < this.props.rows; i++) {\n      let rowRef = [];\n      for (let j = 0; j < this.props.columns; j++)\n        rowRef.push(React.createRef());\n      refs.push(rowRef);\n    }\n    return refs;\n  };\n  changeGridStartNode = (row, column, grid = this.state.grid) => {\n    grid[startNode.row][startNode.column].isStart = false;\n    startNode = { row, column };\n    grid[startNode.row][startNode.column].isStart = true;\n    this.nodeRefs[row][column].current.classList.add(startNodeClass);\n    this.setGrid(grid);\n  };\n  changeGridEndNode = (row, column, grid = this.state.grid) => {\n    grid[endNode.row][endNode.column].isEnd = false;\n    endNode = { row, column };\n    grid[endNode.row][endNode.column].isEnd = true;\n    this.nodeRefs[row][column].current.classList.add(endNodeClass);\n    this.setGrid(grid);\n  };\n  clearVisited = grid => {\n    this.props.setVisited(0);\n    this.props.setShortest(0);\n    grid.forEach(row =>\n      row.forEach(node => {\n        node.isShortestPath = false;\n        node.isVisited = false;\n        this.nodeRefs[node.row][node.col].current.classList.remove(\"visited\");\n        this.nodeRefs[node.row][node.col].current.classList.remove(\n          \"shortest-path\"\n        );\n        this.nodeRefs[node.row][node.col].current.classList.remove(\n          \"visited-anim\"\n        );\n        this.nodeRefs[node.row][node.col].current.classList.remove(\n          \"shortest-path-anim\"\n        );\n      })\n    );\n  };\n  clearGrid = () => {\n    isAnimated = false;\n    this.props.setVisited(0);\n    this.props.setShortest(0);\n    this.setGrid();\n  };\n  visualize = async () => {\n    this.props.setAnimating(true);\n    let grid = this.state.grid;\n    await this.setGrid(grid);\n    this.clearVisited(grid);\n    const response = await this.getResponseFromAlgo(grid, startNode, endNode);\n    const { visitedNodes, shortestPath } = response;\n    visitedNodes.shift();\n    shortestPath.shift();\n    shortestPath.pop();\n    if (visitedNodes.length === 0 && shortestPath.length === 0) {\n      this.props.setAnimating(false);\n      this.setGrid(grid);\n      return;\n    }\n    this.animate(visitedNodes, shortestPath, grid);\n  };\n  getResponseFromAlgo = (grid, sn, en) => {\n    let response;\n    switch (this.props.algo) {\n      case 0:\n        response = dijkstra(grid, sn, en, this.props.diag);\n        break;\n      case 1:\n        response = astar(\n          grid,\n          sn,\n          en,\n          this.props.heuristic[1],\n          this.props.diag\n        );\n        break;\n      case 2:\n        response = jumpPointSearch(grid, sn, en);\n        break;\n      default:\n        break;\n    }\n    return response;\n  };\n  animate = async (visitedNodes, shortestPath, grid) => {\n    let i = 0,\n      j = 0;\n    const animateVisitedNodes = async () => {\n      if (i === visitedNodes.length) {\n        if (shortestPath.length) requestAnimationFrame(animateShortestPath);\n        else {\n          isAnimated = true;\n          this.props.setAnimating(false);\n          this.setGrid(grid);\n        }\n        return;\n      }\n      const { row, col } = visitedNodes[i];\n      this.nodeRefs[row][col].current.classList.add(\"visited-anim\");\n      ++i;\n      this.props.setVisited(i);\n      requestAnimationFrame(animateVisitedNodes);\n    };\n    const animateShortestPath = () => {\n      if (j === shortestPath.length) {\n        isAnimated = true;\n        this.props.setAnimating(false);\n        this.setGrid(grid);\n        return;\n      }\n      const { row, col } = shortestPath[j];\n      this.nodeRefs[row][col].current.classList.add(\"shortest-path-anim\");\n      ++j;\n      this.props.setShortest(j);\n      requestAnimationFrame(animateShortestPath);\n    };\n    await requestAnimationFrame(animateVisitedNodes);\n  };\n\n  visualizeRealTime = (sn, en) => {\n    let grid = this.state.grid;\n    this.clearVisited(grid);\n    const { visitedNodes, shortestPath } = this.getResponseFromAlgo(\n      grid,\n      sn,\n      en\n    );\n    this.props.setVisited(visitedNodes.length);\n    this.props.setShortest(shortestPath.length);\n    visitedNodes.shift();\n    shortestPath.shift();\n    shortestPath.pop();\n    visitedNodes.forEach(node => {\n      this.nodeRefs[node.row][node.col].current.classList.add(\"visited\");\n    });\n    shortestPath.forEach(node => {\n      this.nodeRefs[node.row][node.col].current.classList.add(\"shortest-path\");\n    });\n    return { visitedNodes, shortestPath };\n  };\n\n  visualizeMaze = async () => {\n    await this.clearGrid();\n    let grid = this.state.grid;\n    if (!this.props.animMaze) {\n      this.getResponseFromMaze(grid, this.props.maze);\n      await this.setGrid(grid);\n    } else {\n      this.props.setAnimating(true);\n      await this.setGrid(grid);\n      const {\n        addedWalls,\n        removedWalls,\n        animAddedWalls\n      } = this.getResponseFromMaze(grid);\n      this.animateMaze(addedWalls, removedWalls, grid, animAddedWalls);\n    }\n  };\n\n  getResponseFromMaze = grid => {\n    switch (this.props.maze) {\n      case 0:\n        return kruskal(grid, this.props.rows, this.props.columns);\n      case 1:\n        return prim(grid, this.props.rows, this.props.columns);\n      case 2:\n        return recursiveDivision(grid, this.props.rows, this.props.columns);\n      default:\n        break;\n    }\n  };\n\n  animateMaze = (addedWalls, removedWalls, grid, animAddedWalls) => {\n    let i = 0;\n    const animateAddedWalls = () => {\n      if (i === addedWalls.length) {\n        if (removedWalls.length) requestAnimationFrame(animateRemovedWalls);\n        else {\n          this.props.setAnimating(false);\n          this.setGrid(grid);\n        }\n        return;\n      }\n      const { row, col } = addedWalls[i];\n      this.nodeRefs[row][col].current.classList.add(wallClass);\n      ++i;\n      requestAnimationFrame(animateAddedWalls);\n    };\n    let j = 0;\n    const animateRemovedWalls = () => {\n      if (j === removedWalls.length) {\n        this.props.setAnimating(false);\n        this.setGrid(grid);\n        return;\n      }\n      const { row, col } = removedWalls[j];\n      this.nodeRefs[row][col].current.classList.remove(wallClass);\n      ++j;\n      requestAnimationFrame(animateRemovedWalls);\n    };\n    const showAddedWalls = () => {\n      addedWalls.forEach(node =>\n        this.nodeRefs[node.row][node.col].current.classList.add(wallClass)\n      );\n    };\n    if (animAddedWalls) {\n      requestAnimationFrame(animateAddedWalls);\n    } else {\n      showAddedWalls();\n      requestAnimationFrame(animateRemovedWalls);\n    }\n  };\n}\n\nconst mapStateToProps = state => {\n  return {\n    algo: state.algo,\n    diag: state.diag,\n    heuristic: state.heuristic,\n    maze: state.maze,\n    animMaze: state.animMaze,\n    anim: state.anim\n  };\n};\n\nexport default connect(\n  mapStateToProps,\n  { setAnimating, setVisited, setShortest },\n  null,\n  {\n    forwardRef: true\n  }\n)(TGrid);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}